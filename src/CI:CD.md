## Part 1. CI/CD

- ##### Поднимем виртуальную машину Ubuntu Server 22.04 LTS
![1](images/1.png)

- ##### Скачаем и установим на виртуальную машину **gitlab-runner**.
по методу с [официального сайта](https://docs.gitlab.com/runner/install/linux-manually.html)

![2](images/2.png)

- ##### Запустим **gitlab-runner** и зарегистрируем его для использования в текущем проекте (*DO6_CICD*)
![3](images/3.png)
![3 .1](images/3.1.png)

### Part 2. Сборка

#### Напишем этап для **CI** по сборке приложений из проекта *C2_SimpleBashUtils*.

- ##### Создаем .gitlab-ci.yml файл в корне  репозитория. В файл добавим этап запуска сборки через мейк файл из проекта _C2_.
- ##### Добавим пункт чтобы файлы, полученные после сборки (артефакты), сохрани в произвольную директорию со сроком хранения 30 дней.
![4](images/4.png)

stages: этот раздел определяет последовательность действий.
build-job: этот раздел определяет задание, которое будет выполняться на этапе. 
tags: в этом разделе указаны теги, с которыми должно выполняться задание. 
script: этот раздел определяет команды, которые должны выполняться.
artifacts: в этом разделе определяются артефакты, которые должны быть созданы заданием. В данном случае параметр указывает, что артефакты следует хранить в течение 30 дней.

 ### Part 3. Тест кодстайла

#### Напишем этап для **CI**, который запускает скрипт кодстайла (*clang-format*).
![5](images/5.1.png)
![5](images/5.png)
![6](images/6.png)

##### Если кодстайл не прошел, то «зафейли» пайплайн.
![7](images/7.png)

### Part 4. Интеграционные тесты

#### Напишем этап для **CI**, который запускает интеграционные тесты из того же проекта.
![8](images/8.png)

##### Запустим этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно.
![9](images/9.png)

##### В пайплайне отобразим вывод, что интеграционные тесты успешно прошли / провалились.
![11](images/11.png)

### Part 5. Этап деплоя

##### Поднимем вторую виртуальную машину *Ubuntu Server 22.04 LTS*.
![12](images/12.png)

#### Напишем этап для **CD**, который «разворачивает» проект на другой виртуальной машине.
![13](images/13.png)

- ##### Напишем bash-скрипт, который при помощи **ssh** и **scp** копирует файлы, полученные после сборки (артефакты), в директорию */usr/local/bin* второй виртуальной машины.
![14](images/14.png)

- ##### В файле _gitlab-ci.yml_ добавим этап запуска написанного скрипта.
![16](images/16.png)

- ##### В конфигурационном файле на первой машине добавим строку `environment = ["SSH_AUTH_SOCK=/tmp/ssh-agent"]` Добавление этой строки позволяет указать путь к сокету агента SSH.
- ##### Ключ удаленного сервера добавляем в файл known_hosts на машине gitlab-runner.
![14](images/13.1.png)

- ##### Далее коипруем содержимое shh-ключа на удаленный сервер с помощью клманды
`ssh-copy-id [zekemath@192.168.100.10]`

- ##### После запуска увидим, что файлы усешно скопированы в директорию */usr/local/bin* второй виртуальной машины.
![17](images/16.1.png)

- ##### Этап деплоя успешно пройден.
![18](images/17.png)

### Part 6. Дополнительно. Уведомления

- ##### Регестрируем нового Телеграм бота используя "BotFather", получаем API.
![19](images/18.png)

- ##### Получаем наш ID используя "GetmyID" бота.
![19](images/19.png)

- ##### Пишем скрипт который будет выводить результат о успешном/неуспешном выполнении пайплайна через бота используя полученные ранее данные.
![20](images/20.png)

- ##### В .yml файле добавляем инструкции after_script на каждом этапе.
![21](images/21.png)

- ##### Проверяем работу бота.
![22](images/22.png)